// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: recipe.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createRecipe = `-- name: CreateRecipe :one
INSERT INTO recipes (
  author_id,
  forked_from,
  slug,
  private
) VALUES (
  $1,
  $2,
  $3,
  $4
) RETURNING
  id,
  author_id,
  slug,
  private,
  initial_publish_date,
  forked_from,
  featured_revision
`

type CreateRecipeParams struct {
	AuthorID   pgtype.UUID
	ForkedFrom pgtype.UUID
	Slug       string
	Private    bool
}

func (q *Queries) CreateRecipe(ctx context.Context, arg CreateRecipeParams) (Recipe, error) {
	row := q.db.QueryRow(ctx, createRecipe,
		arg.AuthorID,
		arg.ForkedFrom,
		arg.Slug,
		arg.Private,
	)
	var i Recipe
	err := row.Scan(
		&i.ID,
		&i.AuthorID,
		&i.Slug,
		&i.Private,
		&i.InitialPublishDate,
		&i.ForkedFrom,
		&i.FeaturedRevision,
	)
	return i, err
}

const getRecipeById = `-- name: GetRecipeById :one
SELECT
  id,
  author_id,
  slug,
  private,
  initial_publish_date,
  forked_from,
  featured_revision
FROM
  recipes
WHERE
  id = $1
LIMIT 1
`

func (q *Queries) GetRecipeById(ctx context.Context, id pgtype.UUID) (Recipe, error) {
	row := q.db.QueryRow(ctx, getRecipeById, id)
	var i Recipe
	err := row.Scan(
		&i.ID,
		&i.AuthorID,
		&i.Slug,
		&i.Private,
		&i.InitialPublishDate,
		&i.ForkedFrom,
		&i.FeaturedRevision,
	)
	return i, err
}

const getRecipeByRevisionID = `-- name: GetRecipeByRevisionID :one
SELECT
  recipes.id,
  recipes.author_id,
  recipes.slug,
  recipes.private,
  recipes.initial_publish_date,
  recipes.forked_from,
  recipes.featured_revision
FROM
  recipe_revisions
JOIN
  recipes ON recipe_revisions.recipe_id = recipes.id
WHERE
  recipes.id = $1
LIMIT 1
`

func (q *Queries) GetRecipeByRevisionID(ctx context.Context, id pgtype.UUID) (Recipe, error) {
	row := q.db.QueryRow(ctx, getRecipeByRevisionID, id)
	var i Recipe
	err := row.Scan(
		&i.ID,
		&i.AuthorID,
		&i.Slug,
		&i.Private,
		&i.InitialPublishDate,
		&i.ForkedFrom,
		&i.FeaturedRevision,
	)
	return i, err
}

const getRecipeBySlug = `-- name: GetRecipeBySlug :one
SELECT
  id,
  author_id,
  slug,
  private,
  initial_publish_date,
  forked_from,
  featured_revision
FROM
  recipes
WHERE
  slug = $1
LIMIT 1
`

func (q *Queries) GetRecipeBySlug(ctx context.Context, slug string) (Recipe, error) {
	row := q.db.QueryRow(ctx, getRecipeBySlug, slug)
	var i Recipe
	err := row.Scan(
		&i.ID,
		&i.AuthorID,
		&i.Slug,
		&i.Private,
		&i.InitialPublishDate,
		&i.ForkedFrom,
		&i.FeaturedRevision,
	)
	return i, err
}

const getRecipeRevisionByParentID = `-- name: GetRecipeRevisionByParentID :one
SELECT
  parent.id,
  parent.recipe_id,
  parent.parent_id,
  parent.recipe_description,
  parent.change_comment,
  parent.title,
  parent.publish_date
FROM
  recipe_revisions child
JOIN
  recipe_revisions parent ON child.parent_id = parent.id
WHERE
  recipe_revisions.id = $1
LIMIT 1
`

func (q *Queries) GetRecipeRevisionByParentID(ctx context.Context, id pgtype.UUID) (RecipeRevision, error) {
	row := q.db.QueryRow(ctx, getRecipeRevisionByParentID, id)
	var i RecipeRevision
	err := row.Scan(
		&i.ID,
		&i.RecipeID,
		&i.ParentID,
		&i.RecipeDescription,
		&i.ChangeComment,
		&i.Title,
		&i.PublishDate,
	)
	return i, err
}

const listIngredientsByRecipeRevisionID = `-- name: ListIngredientsByRecipeRevisionID :many
SELECT
  recipe_ingredients.id,
  recipe_ingredients.revision_id,
  recipe_ingredients.ingredient_id,
  recipe_ingredients.quantity,
  recipe_ingredients.measurement_unit_id,
  recipe_ingredients.comment
FROM
  recipe_revisions
JOIN
  recipe_ingredients ON recipe_revisions.id = recipe_ingredients.revision_id
WHERE
  recipe_revisions.id = $1
ORDER BY recipe_ingredients.id
`

func (q *Queries) ListIngredientsByRecipeRevisionID(ctx context.Context, id pgtype.UUID) ([]RecipeIngredient, error) {
	rows, err := q.db.Query(ctx, listIngredientsByRecipeRevisionID, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []RecipeIngredient
	for rows.Next() {
		var i RecipeIngredient
		if err := rows.Scan(
			&i.ID,
			&i.RevisionID,
			&i.IngredientID,
			&i.Quantity,
			&i.MeasurementUnitID,
			&i.Comment,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRecipes = `-- name: ListRecipes :many
SELECT
  id,
  author_id,
  slug,
  private,
  initial_publish_date,
  forked_from,
  featured_revision
FROM
  recipes
WHERE
  CASE
    WHEN $1::uuid IS NOT NULL THEN author_id = $1::uuid
    ELSE true
  END
  AND
  CASE
    WHEN $2::uuid IS NOT NULL THEN forked_from = $2::uuid
    ELSE true
  END
  AND
  CASE
    WHEN $3::uuid IS NOT NULL AND $4::bool IS NOT NULL AND $4::bool THEN author_id = $3::uuid AND private = true
    ELSE private = false OR private IS NULL
  END
  AND
  CASE
    WHEN $5::timestamp IS NOT NULL THEN initial_publish_date >= $5::timestamp
    ELSE true
  END
  AND
  CASE
    WHEN $6::timestamp IS NOT NULL THEN initial_publish_date <= $6::timestamp
    ELSE true
  END
  AND
  CASE
    WHEN $7::text = 'publish_date' AND $8::bool AND $9::timestamp IS NOT NULL THEN $9::timestamp > initial_publish_date
    ELSE true
  END
  AND
  CASE
    WHEN NOT $8::bool AND $7::text = 'publish_date' AND $9::timestamp IS NOT NULL THEN $9::timestamp < initial_publish_date
    ELSE true
  END
  AND
  CASE
    WHEN $7::text = 'slug' AND $8::bool AND $10::text IS NOT NULL THEN $10::text > slug
    ELSE true
  END
  AND
  CASE
    WHEN NOT $8::bool AND $7::text = 'slug' AND $10::text IS NOT NULL THEN $10::text < slug
    ELSE true
  END
ORDER BY
  CASE WHEN $7::text = 'publish_date' AND $8::bool THEN initial_publish_date END DESC,
  CASE WHEN $7::text = 'publish_date' AND NOT $8::bool THEN initial_publish_date END ASC,
  CASE WHEN $7::text = 'slug' AND $8::bool THEN slug END DESC,
  CASE WHEN $7::text = 'slug' AND NOT $8::bool THEN slug END ASC
LIMIT $11
`

type ListRecipesParams struct {
	AuthorID      pgtype.UUID
	ForkedFrom    pgtype.UUID
	CurrentUser   pgtype.UUID
	Private       pgtype.Bool
	PublishStart  pgtype.Timestamp
	PublishEnd    pgtype.Timestamp
	SortCol       string
	SortDir       bool
	PublishCursor pgtype.Timestamp
	SlugCursor    pgtype.Text
	Limit         int32
}

func (q *Queries) ListRecipes(ctx context.Context, arg ListRecipesParams) ([]Recipe, error) {
	rows, err := q.db.Query(ctx, listRecipes,
		arg.AuthorID,
		arg.ForkedFrom,
		arg.CurrentUser,
		arg.Private,
		arg.PublishStart,
		arg.PublishEnd,
		arg.SortCol,
		arg.SortDir,
		arg.PublishCursor,
		arg.SlugCursor,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Recipe
	for rows.Next() {
		var i Recipe
		if err := rows.Scan(
			&i.ID,
			&i.AuthorID,
			&i.Slug,
			&i.Private,
			&i.InitialPublishDate,
			&i.ForkedFrom,
			&i.FeaturedRevision,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listStepsByRecipeRevisionID = `-- name: ListStepsByRecipeRevisionID :many
SELECT
  recipe_steps.id,
  recipe_steps.revision_id,
  recipe_steps.content,
  recipe_steps.index
FROM
  recipe_revisions
JOIN
  recipe_steps ON recipe_revisions.id = recipe_steps.revision_id
WHERE
  recipe_revisions.id = $1
ORDER BY
  recipe_steps.index
`

func (q *Queries) ListStepsByRecipeRevisionID(ctx context.Context, id pgtype.UUID) ([]RecipeStep, error) {
	rows, err := q.db.Query(ctx, listStepsByRecipeRevisionID, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []RecipeStep
	for rows.Next() {
		var i RecipeStep
		if err := rows.Scan(
			&i.ID,
			&i.RevisionID,
			&i.Content,
			&i.Index,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateRecipe = `-- name: UpdateRecipe :one
UPDATE recipes
SET
  slug = coalesce($1, slug),
  private = coalesce($2, private),
  featured_revision = coalesce($3, featured_revision)
WHERE id = $4
RETURNING
  id,
  author_id,
  slug,
  private,
  initial_publish_date,
  forked_from,
  featured_revision
`

type UpdateRecipeParams struct {
	Slug             string
	Private          bool
	FeaturedRevision pgtype.UUID
	ID               pgtype.UUID
}

func (q *Queries) UpdateRecipe(ctx context.Context, arg UpdateRecipeParams) (Recipe, error) {
	row := q.db.QueryRow(ctx, updateRecipe,
		arg.Slug,
		arg.Private,
		arg.FeaturedRevision,
		arg.ID,
	)
	var i Recipe
	err := row.Scan(
		&i.ID,
		&i.AuthorID,
		&i.Slug,
		&i.Private,
		&i.InitialPublishDate,
		&i.ForkedFrom,
		&i.FeaturedRevision,
	)
	return i, err
}

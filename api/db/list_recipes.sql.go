// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: list_recipes.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const listRecipes = `-- name: ListRecipes :many
SELECT
  id,
  author_id,
  slug,
  private,
  initial_publish_date,
  forked_from,
  featured_revision
FROM
  recipes
WHERE
  CASE
    WHEN $1::uuid IS NOT NULL THEN author_id = $1::uuid
    ELSE true
  END
  AND
  CASE
    WHEN $2::uuid IS NOT NULL THEN forked_from = $2::uuid
    ELSE true
  END
  AND
  CASE
    WHEN $3::uuid IS NOT NULL AND $4::bool IS NOT NULL AND $4::bool THEN author_id = $3::uuid AND private = true
    ELSE private = false OR private IS NULL
  END
  AND
  CASE
    WHEN $5::timestamp IS NOT NULL THEN initial_publish_date >= $5::timestamp
    ELSE true
  END
  AND
  CASE
    WHEN $6::timestamp IS NOT NULL THEN initial_publish_date <= $6::timestamp
    ELSE true
  END
  AND
  CASE
    WHEN $7::text = 'publish_date' AND $8::bool AND $9::timestamp IS NOT NULL THEN $9::timestamp > initial_publish_date
    ELSE true
  END
  AND
  CASE
    WHEN NOT $8::bool AND $7::text = 'publish_date' AND $9::timestamp IS NOT NULL THEN $9::timestamp < initial_publish_date
    ELSE true
  END
  AND
  CASE
    WHEN $7::text = 'slug' AND $8::bool AND $10::text IS NOT NULL THEN $10::text > slug
    ELSE true
  END
  AND
  CASE
    WHEN NOT $8::bool AND $7::text = 'slug' AND $10::text IS NOT NULL THEN $10::text < slug
    ELSE true
  END
ORDER BY
  CASE WHEN $7::text = 'publish_date' AND $8::bool THEN initial_publish_date END DESC,
  CASE WHEN $7::text = 'publish_date' AND NOT $8::bool THEN initial_publish_date END ASC,
  CASE WHEN $7::text = 'slug' AND $8::bool THEN slug END DESC,
  CASE WHEN $7::text = 'slug' AND NOT $8::bool THEN slug END ASC
LIMIT $11
`

type ListRecipesParams struct {
	AuthorID      pgtype.UUID
	ForkedFrom    pgtype.UUID
	CurrentUser   pgtype.UUID
	Private       pgtype.Bool
	PublishStart  pgtype.Timestamp
	PublishEnd    pgtype.Timestamp
	SortCol       string
	SortDir       bool
	PublishCursor pgtype.Timestamp
	SlugCursor    pgtype.Text
	Limit         int32
}

func (q *Queries) ListRecipes(ctx context.Context, arg ListRecipesParams) ([]Recipe, error) {
	rows, err := q.db.Query(ctx, listRecipes,
		arg.AuthorID,
		arg.ForkedFrom,
		arg.CurrentUser,
		arg.Private,
		arg.PublishStart,
		arg.PublishEnd,
		arg.SortCol,
		arg.SortDir,
		arg.PublishCursor,
		arg.SlugCursor,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Recipe
	for rows.Next() {
		var i Recipe
		if err := rows.Scan(
			&i.ID,
			&i.AuthorID,
			&i.Slug,
			&i.Private,
			&i.InitialPublishDate,
			&i.ForkedFrom,
			&i.FeaturedRevision,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

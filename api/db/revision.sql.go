// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: revision.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createRevision = `-- name: CreateRevision :one
INSERT INTO recipe_revisions (
  recipe_id,
  parent_id,
  recipe_description,
  change_comment,
  title
)
VALUES (
  $1,
  $2,
  $3,
  $4,
  $5
)
RETURNING
  recipe_revisions.id,
  recipe_revisions.recipe_id,
  recipe_revisions.parent_id,
  recipe_revisions.recipe_description,
  recipe_revisions.change_comment,
  recipe_revisions.title,
  recipe_revisions.publish_date
`

type CreateRevisionParams struct {
	RecipeID          pgtype.UUID
	ParentID          pgtype.UUID
	RecipeDescription pgtype.Text
	ChangeComment     pgtype.Text
	Title             string
}

func (q *Queries) CreateRevision(ctx context.Context, arg CreateRevisionParams) (RecipeRevision, error) {
	row := q.db.QueryRow(ctx, createRevision,
		arg.RecipeID,
		arg.ParentID,
		arg.RecipeDescription,
		arg.ChangeComment,
		arg.Title,
	)
	var i RecipeRevision
	err := row.Scan(
		&i.ID,
		&i.RecipeID,
		&i.ParentID,
		&i.RecipeDescription,
		&i.ChangeComment,
		&i.Title,
		&i.PublishDate,
	)
	return i, err
}

const createRevisionIngredient = `-- name: CreateRevisionIngredient :one
INSERT INTO
  recipe_ingredients (
    revision_id,
    ingredient_id,
    measurement_unit_id,
    quantity,
    comment
)
VALUES (
  $1,
  $2,
  $3,
  $4,
  $5
)
RETURNING
  recipe_ingredients.id,
  recipe_ingredients.revision_id,
  recipe_ingredients.ingredient_id,
  recipe_ingredients.quantity,
  recipe_ingredients.measurement_unit_id,
  recipe_ingredients.comment
`

type CreateRevisionIngredientParams struct {
	RevisionID        pgtype.UUID
	IngredientID      int64
	MeasurementUnitID int64
	Quantity          float32
	Comment           pgtype.Text
}

func (q *Queries) CreateRevisionIngredient(ctx context.Context, arg CreateRevisionIngredientParams) (RecipeIngredient, error) {
	row := q.db.QueryRow(ctx, createRevisionIngredient,
		arg.RevisionID,
		arg.IngredientID,
		arg.MeasurementUnitID,
		arg.Quantity,
		arg.Comment,
	)
	var i RecipeIngredient
	err := row.Scan(
		&i.ID,
		&i.RevisionID,
		&i.IngredientID,
		&i.Quantity,
		&i.MeasurementUnitID,
		&i.Comment,
	)
	return i, err
}

const createRevisionStep = `-- name: CreateRevisionStep :one
INSERT INTO
  recipe_steps (
    revision_id,
    content,
    index
  )
VALUES (
  $1,
  $2,
  $3
)
RETURNING
  recipe_steps.id,
  recipe_steps.revision_id,
  recipe_steps.content,
  recipe_steps.index
`

type CreateRevisionStepParams struct {
	RevisionID pgtype.UUID
	Content    string
	Index      int32
}

func (q *Queries) CreateRevisionStep(ctx context.Context, arg CreateRevisionStepParams) (RecipeStep, error) {
	row := q.db.QueryRow(ctx, createRevisionStep, arg.RevisionID, arg.Content, arg.Index)
	var i RecipeStep
	err := row.Scan(
		&i.ID,
		&i.RevisionID,
		&i.Content,
		&i.Index,
	)
	return i, err
}

const getFeaturedRevisionByRecipeId = `-- name: GetFeaturedRevisionByRecipeId :one
SELECT
  recipe_revisions.id,
  recipe_revisions.recipe_id,
  recipe_revisions.parent_id,
  recipe_revisions.recipe_description,
  recipe_revisions.change_comment,
  recipe_revisions.title,
  recipe_revisions.publish_date
FROM
  recipes
JOIN recipe_revisions ON recipes.featured_revision = recipe_revisions.id
WHERE
  recipes.id = $1
LIMIT 1
`

func (q *Queries) GetFeaturedRevisionByRecipeId(ctx context.Context, id pgtype.UUID) (RecipeRevision, error) {
	row := q.db.QueryRow(ctx, getFeaturedRevisionByRecipeId, id)
	var i RecipeRevision
	err := row.Scan(
		&i.ID,
		&i.RecipeID,
		&i.ParentID,
		&i.RecipeDescription,
		&i.ChangeComment,
		&i.Title,
		&i.PublishDate,
	)
	return i, err
}

const getForkedFromRevisionByRecipeId = `-- name: GetForkedFromRevisionByRecipeId :one

SELECT
  recipe_revisions.id,
  recipe_revisions.recipe_id,
  recipe_revisions.parent_id,
  recipe_revisions.recipe_description,
  recipe_revisions.change_comment,
  recipe_revisions.title,
  recipe_revisions.publish_date
FROM
  recipes
JOIN recipe_revisions ON recipes.forked_from = recipe_revisions.id
WHERE
  recipes.id = $1
LIMIT 1
`

// Limit for pagination
func (q *Queries) GetForkedFromRevisionByRecipeId(ctx context.Context, id pgtype.UUID) (RecipeRevision, error) {
	row := q.db.QueryRow(ctx, getForkedFromRevisionByRecipeId, id)
	var i RecipeRevision
	err := row.Scan(
		&i.ID,
		&i.RecipeID,
		&i.ParentID,
		&i.RecipeDescription,
		&i.ChangeComment,
		&i.Title,
		&i.PublishDate,
	)
	return i, err
}

const getRecipeRevisionById = `-- name: GetRecipeRevisionById :one
SELECT
  id,
  recipe_id,
  parent_id,
  recipe_description,
  change_comment,
  title,
  publish_date
FROM
  recipe_revisions
WHERE
  id = $1
LIMIT 1
`

func (q *Queries) GetRecipeRevisionById(ctx context.Context, id pgtype.UUID) (RecipeRevision, error) {
	row := q.db.QueryRow(ctx, getRecipeRevisionById, id)
	var i RecipeRevision
	err := row.Scan(
		&i.ID,
		&i.RecipeID,
		&i.ParentID,
		&i.RecipeDescription,
		&i.ChangeComment,
		&i.Title,
		&i.PublishDate,
	)
	return i, err
}

const getRecipeRevisionByIngredientId = `-- name: GetRecipeRevisionByIngredientId :one
SELECT
  recipe_revisions.id,
  recipe_revisions.recipe_id,
  recipe_revisions.parent_id,
  recipe_revisions.recipe_description,
  recipe_revisions.change_comment,
  recipe_revisions.title,
  recipe_revisions.publish_date
FROM
  recipe_ingredients
JOIN
  recipe_revisions ON recipe_ingredients.revision_id = recipe_revisions.id
WHERE
  recipe_ingredients.id = $1
LIMIT 1
`

func (q *Queries) GetRecipeRevisionByIngredientId(ctx context.Context, id int64) (RecipeRevision, error) {
	row := q.db.QueryRow(ctx, getRecipeRevisionByIngredientId, id)
	var i RecipeRevision
	err := row.Scan(
		&i.ID,
		&i.RecipeID,
		&i.ParentID,
		&i.RecipeDescription,
		&i.ChangeComment,
		&i.Title,
		&i.PublishDate,
	)
	return i, err
}

const getRecipeRevisionByStepId = `-- name: GetRecipeRevisionByStepId :one
SELECT
  recipe_revisions.id,
  recipe_revisions.recipe_id,
  recipe_revisions.parent_id,
  recipe_revisions.recipe_description,
  recipe_revisions.change_comment,
  recipe_revisions.title,
  recipe_revisions.publish_date
FROM
  recipe_steps
JOIN
  recipe_revisions ON recipe_steps.revision_id = recipe_revisions.id
WHERE
  recipe_steps.id = $1
LIMIT 1
`

func (q *Queries) GetRecipeRevisionByStepId(ctx context.Context, id int64) (RecipeRevision, error) {
	row := q.db.QueryRow(ctx, getRecipeRevisionByStepId, id)
	var i RecipeRevision
	err := row.Scan(
		&i.ID,
		&i.RecipeID,
		&i.ParentID,
		&i.RecipeDescription,
		&i.ChangeComment,
		&i.Title,
		&i.PublishDate,
	)
	return i, err
}

const listRevisions = `-- name: ListRevisions :many
SELECT
  id,
  recipe_id,
  parent_id,
  recipe_description,
  change_comment,
  title,
  publish_date
FROM
  recipe_revisions
WHERE
  CASE
    WHEN $1::uuid IS NOT NULL THEN $1::uuid = recipe_id
    ELSE true
  END
  AND
  CASE
    WHEN $2::uuid IS NOT NULL THEN $2::uuid = parent_id
    ELSE true
  END
  AND
  CASE
    WHEN $3::timestamp IS NOT NULL THEN publish_date >= $3::timestamp
    ELSE true
  END
  AND
  CASE
    WHEN $4::timestamp IS NOT NULL THEN publish_date <= $4::timestamp
    ELSE true
  END
  AND
  CASE
    WHEN $5::text = 'publish_date' AND $6::bool AND $7::timestamp IS NOT NULL THEN $7::timestamp > publish_date
    ELSE true
  END
  AND
  CASE
    WHEN NOT $6::bool AND $5::text = 'publish_date' AND $7::timestamp IS NOT NULL THEN $7::timestamp < publish_date
    ELSE true
  END
ORDER BY
  CASE WHEN $5::text = 'publish_date' AND $6::bool THEN publish_date END DESC,
  CASE WHEN $5::text = 'publish_date' AND NOT $6::bool THEN publish_date END ASC
LIMIT $8
`

type ListRevisionsParams struct {
	RecipeID      pgtype.UUID
	ParentID      pgtype.UUID
	PublishStart  pgtype.Timestamp
	PublishEnd    pgtype.Timestamp
	SortCol       string
	SortDir       bool
	PublishCursor pgtype.Timestamp
	Limit         int32
}

func (q *Queries) ListRevisions(ctx context.Context, arg ListRevisionsParams) ([]RecipeRevision, error) {
	rows, err := q.db.Query(ctx, listRevisions,
		arg.RecipeID,
		arg.ParentID,
		arg.PublishStart,
		arg.PublishEnd,
		arg.SortCol,
		arg.SortDir,
		arg.PublishCursor,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []RecipeRevision
	for rows.Next() {
		var i RecipeRevision
		if err := rows.Scan(
			&i.ID,
			&i.RecipeID,
			&i.ParentID,
			&i.RecipeDescription,
			&i.ChangeComment,
			&i.Title,
			&i.PublishDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

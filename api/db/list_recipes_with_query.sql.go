// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: list_recipes_with_query.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const listRecipesWithQuery = `-- name: ListRecipesWithQuery :many
WITH rankings AS (
  SELECT
    r.id, r.author_id, r.slug, r.private, r.initial_publish_date, r.forked_from, r.featured_revision,
    ts_rank(setweight(to_tsvector('english', title), 'A') || setweight(to_tsvector('english', coalesce(recipe_description, '')), 'B'), websearch_to_tsquery('english', $12)) AS rank
  FROM
    recipes r
  JOIN LATERAL (
    SELECT id, recipe_id, parent_id, recipe_description, change_comment, title, publish_date, photo
    FROM recipe_revisions
    WHERE
      -- If featured_revision is set, fetch that
      (r.featured_revision IS NOT NULL AND id = r.featured_revision)
      -- Otherwise, fetch the latest revision for this recipe
      OR (r.featured_revision IS NULL AND recipe_id = r.id)
    ORDER BY
      -- If featured_revision is set, this will be 1 row, so order doesn't matter
      -- If not, order by publish_date DESC to get the latest
      publish_date DESC
    LIMIT 1
  ) rev ON TRUE
)
SELECT
  id,
  author_id,
  slug,
  private,
  initial_publish_date,
  forked_from,
  featured_revision,
  rank
FROM
  rankings
WHERE
  rank > 0
  AND
  CASE
    WHEN $1::uuid IS NOT NULL THEN author_id = $1::uuid
    ELSE true
  END
  AND
  CASE
    WHEN $2::uuid IS NOT NULL THEN forked_from = $2::uuid
    ELSE true
  END
  AND
  CASE
    WHEN $3::uuid IS NOT NULL AND $4::bool IS NOT NULL AND $4::bool THEN author_id = $3::uuid AND private = true
    ELSE private = false OR private IS NULL
  END
  AND
  CASE
    WHEN $5::timestamp IS NOT NULL THEN initial_publish_date >= $5::timestamp
    ELSE true
  END
  AND
  CASE
    WHEN $6::timestamp IS NOT NULL THEN initial_publish_date <= $6::timestamp
    ELSE true
  END
  AND
  CASE
    WHEN $7::text = 'publish_date' AND $8::bool AND $9::timestamp IS NOT NULL THEN $9::timestamp > initial_publish_date
    ELSE true
  END
  AND
  CASE
    WHEN NOT $8::bool AND $7::text = 'publish_date' AND $9::timestamp IS NOT NULL THEN $9::timestamp < initial_publish_date
    ELSE true
  END
  AND
  CASE
    WHEN $7::text = 'slug' AND $8::bool AND $10::text IS NOT NULL THEN $10::text > slug
    ELSE true
  END
  AND
  CASE
    WHEN NOT $8::bool AND $7::text = 'slug' AND $10::text IS NOT NULL THEN $10::text < slug
    ELSE true
  END
ORDER BY
  rank desc,
  CASE WHEN $7::text = 'publish_date' AND $8::bool THEN initial_publish_date END DESC,
  CASE WHEN $7::text = 'publish_date' AND NOT $8::bool THEN initial_publish_date END ASC,
  CASE WHEN $7::text = 'slug' AND $8::bool THEN slug END DESC,
  CASE WHEN $7::text = 'slug' AND NOT $8::bool THEN slug END ASC
LIMIT $11
`

type ListRecipesWithQueryParams struct {
	AuthorID      pgtype.UUID
	ForkedFrom    pgtype.UUID
	CurrentUser   pgtype.UUID
	Private       pgtype.Bool
	PublishStart  pgtype.Timestamp
	PublishEnd    pgtype.Timestamp
	SortCol       string
	SortDir       bool
	PublishCursor pgtype.Timestamp
	SlugCursor    pgtype.Text
	Limit         int64
	Query         string
}

type ListRecipesWithQueryRow struct {
	ID                 pgtype.UUID
	AuthorID           pgtype.UUID
	Slug               string
	Private            bool
	InitialPublishDate pgtype.Timestamp
	ForkedFrom         pgtype.UUID
	FeaturedRevision   pgtype.UUID
	Rank               float32
}

func (q *Queries) ListRecipesWithQuery(ctx context.Context, arg ListRecipesWithQueryParams) ([]ListRecipesWithQueryRow, error) {
	rows, err := q.db.Query(ctx, listRecipesWithQuery,
		arg.AuthorID,
		arg.ForkedFrom,
		arg.CurrentUser,
		arg.Private,
		arg.PublishStart,
		arg.PublishEnd,
		arg.SortCol,
		arg.SortDir,
		arg.PublishCursor,
		arg.SlugCursor,
		arg.Limit,
		arg.Query,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListRecipesWithQueryRow
	for rows.Next() {
		var i ListRecipesWithQueryRow
		if err := rows.Scan(
			&i.ID,
			&i.AuthorID,
			&i.Slug,
			&i.Private,
			&i.InitialPublishDate,
			&i.ForkedFrom,
			&i.FeaturedRevision,
			&i.Rank,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
